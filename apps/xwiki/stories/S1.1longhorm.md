
# Story 1.1 — Déployer © (replicas=1) pour volumes persistants

## Contexte & objectif
Sur un **VPS Hetzner unique**, on installe **Longhorn** comme CSI afin de fournir des **volumes persistants** aux workloads (MySQL, XWiki, observabilité). Du fait du **mono‑nœud**, on force la **réplication à 1** pour éviter les volumes `degraded` et les rebuilds inutiles. La politique passera à 2–3 réplicas dès que des nœuds supplémentaires seront ajoutés.

---

## Portée
- Installer **Longhorn** via Helm.
- Créer **2 StorageClasses** : `longhorn` (défaut, ext4, replicas=1) et `longhorn-db` (xfs, replicas=1, WaitForFirstConsumer).
- Activer l’expansion de volume, `dataLocality=best-effort`.
- Exposer l’UI **UNIQUEMENT** en `ClusterIP` (pas d’exposition publique).
- Vérifier provisionnement d’un PVC **smoke test**.

### Hors portée
- Backups Longhorn vers S3 (BackupTarget, RecurringJobs) — **seront ajoutés** plus tard (story Backups).
- Anti‑affinités/HA multi‑nœuds (non pertinent en mono‑nœud).

---

## Prérequis
- Cluster K8s **opérationnel** (CNI OK, kubelet OK).
- Espace disque suffisant pour les volumes (disque du VPS non saturé).
- Node **non root-full** (`df -h`, `iostat` OK).
- `helm` disponible sur la machine d’admin.
- **PSA** au moins `baseline` sur le namespace `longhorn-system`.

---

## Critères d’acceptation (AC)
1. Le chart **longhorn** est installé dans `longhorn-system`, pods `healthy` (manager/engine/instance-manager/ui).
2. La StorageClass **par défaut** s’appelle `longhorn` avec `allowVolumeExpansion=true`, `numberOfReplicas=1`.
3. La StorageClass **DB** `longhorn-db` existe avec `fsType=xfs`, `numberOfReplicas=1`, `volumeBindingMode=WaitForFirstConsumer`.
4. La création d’un PVC **smoke-test** aboutit (`Bound`) et un Pod test **lit/écrit** sur le volume.
5. L’UI Longhorn **n’est pas exposée** publiquement.
6. Documentation courte **runbook** incluse : « comment créer/étendre/restaurer un volume » (hors backup).

---

## Dépendances
- Aucune dépendance forte, mais recommandé d’avoir **kube-prometheus-stack** ensuite pour metrics.

---

## Plan d’implémentation (Ansible)

### 1) Rôle `longhorn`
**tasks/main.yml (exemple d’intentions)**
```yaml
- name: Create namespace longhorn-system
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: longhorn-system
        labels:
          pod-security.kubernetes.io/enforce: "baseline"

- name: Add helm repo longhorn
  kubernetes.core.helm_repository:
    name: longhorn
    repo_url: https://charts.longhorn.io

- name: Install/upgrade longhorn chart
  kubernetes.core.helm:
    name: longhorn
    chart_ref: longhorn/longhorn
    release_namespace: longhorn-system
    create_namespace: false
    values: "{{ longhorn_values }}"
    wait: true
    timeout: 900
```

**group_vars (exemple)**  
```yaml
longhorn_values:
  defaultSettings:
    defaultReplicaCount: 1
    defaultDataLocality: "best-effort"
    allowVolumeExpansion: true
  ingress:
    enabled: false
  csi:
    kubeletRootDir: /var/lib/kubelet  # adapter si custom
```

### 2) StorageClasses
**tasks/storageclasses.yml**
```yaml
- name: SC longhorn (défaut, ext4)
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: storage.k8s.io/v1
      kind: StorageClass
      metadata:
        name: longhorn
        annotations:
          storageclass.kubernetes.io/is-default-class: "true"
      provisioner: driver.longhorn.io
      reclaimPolicy: Retain
      allowVolumeExpansion: true
      volumeBindingMode: Immediate
      parameters:
        numberOfReplicas: "1"
        dataLocality: "best-effort"
        fsType: ext4

- name: SC longhorn-db (xfs, WFFC)
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: storage.k8s.io/v1
      kind: StorageClass
      metadata:
        name: longhorn-db
      provisioner: driver.longhorn.io
      reclaimPolicy: Retain
      allowVolumeExpansion: true
      volumeBindingMode: WaitForFirstConsumer
      parameters:
        numberOfReplicas: "1"
        dataLocality: "best-effort"
        fsType: xfs
```

### 3) Smoke test (PVC + Pod)
**tasks/smoke-test.yml**
```yaml
- name: PVC test
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: PersistentVolumeClaim
      metadata: { name: pvc-longhorn-smoke, namespace: default }
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: longhorn
        resources: { requests: { storage: 1Gi } }

- name: Pod test (busybox)
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Pod
      metadata: { name: pod-longhorn-smoke, namespace: default }
      spec:
        restartPolicy: Never
        containers:
          - name: busybox
            image: busybox:1.36
            command: ["sh","-c","echo OK > /data/ok && cat /data/ok && sleep 5"]
            volumeMounts:
              - name: data
                mountPath: /data
        volumes:
          - name: data
            persistentVolumeClaim:
              claimName: pvc-longhorn-smoke
```

### 4) Nettoyage smoke test (facultatif)
```yaml
- name: Delete smoke test resources
  kubernetes.core.k8s:
    state: absent
    definition: |
      apiVersion: v1
      kind: Pod
      metadata: { name: pod-longhorn-smoke, namespace: default }
---
      apiVersion: v1
      kind: PersistentVolumeClaim
      metadata: { name: pvc-longhorn-smoke, namespace: default }
```

---

## Variables (proposées)
```yaml
longhorn:
  default_replicas: 1
  data_locality: best-effort
  allow_expand: true

storageclasses:
  default_sc:
    name: longhorn
    fs: ext4
    replicas: 1
    binding: Immediate
  db_sc:
    name: longhorn-db
    fs: xfs
    replicas: 1
    binding: WaitForFirstConsumer
```

---

## Sécurité
- Namespace `longhorn-system` sous **PSA baseline** (minimum).
- UI non exposée publiquement (pas d’Ingress ni Service LoadBalancer).
- RBAC par défaut du chart suffisant pour le mono‑nœud.

---

## Observabilité
- À prévoir dans une story suivante : **ServiceMonitor** Longhorn pour Prometheus.  
- En attendant, valider l’état des pods : `kubectl -n longhorn-system get pods`.

---

## Validation / Tests
- `kubectl get sc` → `longhorn (default)` + `longhorn-db` présents.
- `kubectl -n longhorn-system get pods` → tous `Running/Ready`.
- PVC smoke test → `Bound` ; le Pod `busybox` affiche `OK` depuis `/data/ok`.
- `kubectl describe pvc pvc-longhorn-smoke` → provisionner par `driver.longhorn.io`.

---

## Rollback
- `helm -n longhorn-system rollback longhorn <previous>`  
- Supprimer **uniquement** les SC si nécessaire (⚠️ **ne pas** supprimer les CRDs si des volumes existent).

---

## Risques & mitigations
- **Mono‑nœud** → pas de HA des volumes : non bloquant, connu. Passer replicas à 2–3 lorsqu’on ajoute des nœuds.
- **Manque d’espace disque** → vérifier avant (alerte Prometheus à venir).
- **fsType xfs indisponible** → installer le paquet xfsprogs sur l’hôte si besoin.

---

## Définition de prêt (DoR)
- Cluster K8s OK, accès `kubectl`/`helm` OK.
- Espace disque suffisant validé.
- Fenêtre de déploiement définie.

## Définition de fait (DoD)
- Chart Longhorn installé, pods `Ready`.
- SC `longhorn` par défaut + SC `longhorn-db` créées.
- Smoke test PVC/Pod **passé**.
- Runbook court ajouté à la doc (création/extension volume, UI locale).

